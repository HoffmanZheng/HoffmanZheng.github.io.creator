---
title: "Java：HashMap 源码解读"
author: "Chenghao Zheng"
tags: ["Java"]
categories: ["Study notes"]
date: 2020-01-28T14:11:47+01:00
draft: false
---

# HashMap 源码解读

### 1. 概述

> 哈希表是基于 Map 接口的实现。它提供了所有可选的 Map 操作并且允许 null 作为 key 和 value。HashMap大体上与 `HashTable` 相同，只是 **没有同步** 和允许了 null 作为键值。这个类 **不保证数据的有序性**，特别是，不保证数据的顺序随着时间不会改变。

> 假设哈希方程把数据均匀的分散在哈希桶中，这个实现可以提供 O(1) 的基础操作（get / put）性能。哈希表中的迭代所需要的时间和表的容量+键值对的数量成正比。因此，当迭代效率很重要时，不把初始容量设置的过高是非常重要的。

### 2. 初始容量及装载因子

> 影响一个哈希表实例性能的两个参数：初始容量和装载因子。哈希表的容量是表中哈希桶的数量，初始容量    `initial capacity` 则是哈希表被创建时的容量。装载因子 `load factor` 是用来描述哈希桶自动扩容前所允许的数据最大填充程度的一个衡量。当哈希表中键值对的数量超过装载因子和当前容量的乘积后，哈希表会执行 `rehash` 操作， 即内部的数据结构会进行重构，哈希桶的数量会变成现在的两倍。

>  作为一条基本规则，默认的装载因子 0.75 提供了一个较好的时间和空间的权衡。高的装载因子会降低空间开销但提高了查询成本（反应在哈希表的大多数操作上，包括 get / put）。在设置哈希表初始容量时需要考虑表中预期存储的键值对的数量以及装载因子，来尽可能的降低 `rehash` 发生的次数。如果初始容量大于键值对最大数 / 装载因子，rehash 将永远不会发生。

# HashMap 的实现原理

### 1. 哈希表底层实现原理

### 2. 为什么采用数组+链表的数据结构

### 3. 哈希冲突还有哪些解决办法

### 4. 为什么不用 LinkedList / ArrayList 代替数组结构



# HashMap 扩容

### 1. HashMap 在什么条件下扩容

### 2. 为什么扩容是2的n次幂

相比于 % 取模，哈希表选择 `(n - 1) & hash` 这个更高效率的按位与运算作为哈希桶的索引运算，2^n 的二进制为 10000.. 而这样哈希桶的最大 index = 2^n -1，二进制就成了 01111.. 再与对象的哈希值做按位与运算，就能快速的计算出对应哈希桶 index 值，并且是分布均匀的。

若在创建哈希表时给定初始容量，哈希表也会用 `roundUpToPowerOf2` / `tableSizeFor` 将其扩充为2的幂次方大小。

```java
// Returns a power of two size for the given target capacity. 

static final int tableSizeFor(int cap) {
	int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

### 3. 为什么要先高16位异或低16位再取模运算



# HashMap 的 get / put 过程

### 1. 哈希表的 put 过程

### 2. 哈希表的 get 过程

### 3. 还有哪些哈希算法

### 4. 字符串中 hashCode 的实现





# JDK 1.8 对 HashMap 的改进

### 1. JDK 1.7 的 HashMap 存在的问题

#### 1.1 HashMap CVE 安全隐患

`Tomcat` 在2011年邮件中报道了哈希表可以通过精心构造的恶意 http 请求造成链表性能退化，并引发网站 DoS 拒绝服务攻击的现象。这个问题在之后的 JDK 7 中得到了解决：对传进来的字符串进行特殊的哈希运算 `stringHash32` ，来避免恶意的字符串传值造成的哈希表链表性能退化的情况。

```java
final int hash(Object k) {
	if (0 != h && k instanceof String) {
		return sun.misc.Hashing.stringHash32((String) k);
	}
    ...
}
```

#### 1.2 HashMap 多线程操作导致死循环问题

主要原因在于并发下 HashMap 扩容时，往新的 HashMap 转移数据可能产生循环链表（此处链表插入是往前插入的，导致和原哈希桶中的位置相反，产生环形链表），导致之后在该哈希桶中搜索键值时可能会发生的死锁现象。[详情查看酷壳：Java HashMap 的死循环](https://coolshell.cn/articles/9606.html)

不过，JDK 1.8 后解决了这个问题（使用了保持顺序的扩容 transfer 操作），但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。

### 2. JDK 1.8 之前的 HashMap 源码实现

JDK 1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过 **扰动函数处** 理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

* 扰动函数（减少哈希碰撞）

```java
/* 源码注释：对原有对象的哈希值进行一次补充的哈希运算得到结果值，
来防止低质量的哈希方程。这是非常重要的，
因为哈希表用2的幂用为哈希表的长度，在低位bits相同时就会发生哈希碰撞。*/

final int hash(Object k) {
	h ^= (h >>> 20) ^ (h >>> 12);
	return h ^ (h >>> 7) ^ (h >>> 4);
}
```

* 链地址法解决哈希碰撞

思想：为每个哈希值建立一个单链表，当发生哈希碰撞时，将记录插入到链表中。

![链地址法解决哈希碰撞](/images/HashBucketLinked.png)

### 3. JDK 1.8 之后的 HashMap 底层实现

相比于之前的版本， JDK 1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。（TreeMap、TreeSet 以及 JDK 1.8 之后的 HashMap 底层都用到了红黑树。）

**为什么选择 8 作为阈值** 

因为理想情况下，随机哈希值遵循参数为 0.5 的泊松分布，如此在同一个哈希桶中出现 8 个以上数据的概率是极低的。

![JDK 1.8 之后的哈希表结构](/images/HashMapTreeSet.jpeg)

### 4. 新的哈希算法

JDK 1.8 的 hash 方法相比于 JDK 1.7 hash 方法原理不变，但是减少了扰动次数，更加简化，并提高了运算性能。

```java
/* 源码注释：将哈希值的较高位对低位进行异或运算，来避免低位相同、只有高位不同的哈希值发生的碰撞。
这是一种在速度、实用性和位扩展之间的权衡。因此我们用最便宜的方式，减少系统损失，以及合并高位哈希值
的影响，否则这些高位哈希值将由于哈希表长度范围的限制永远不会在索引计算中使用*/

static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

### 5. 为什么不直接用红黑树，而选择先用链表再转红黑树

### 6. 能否用二叉查找树代替红黑树

### 7. 为什么阈值是 8 呢

### 8. 当链表转为红黑树后，什么时候退化为链表



# HashMap 的并发问题

### 1. HashMap在并发编程环境下有什么问题啊

### 2. 在jdk1.8中还有这些问题么

### 3. 你一般怎么解决这些问题的



# HashMap key 问题

### 1. 键可以为 Null 值么
### 2. 你一般用什么作为 HashMap 的 key
### 3. 我用可变类当 HashMap 的 key 有什么问题
### 4. 如果实现让一个自定义的 class 作为 HashMap 的 key 



