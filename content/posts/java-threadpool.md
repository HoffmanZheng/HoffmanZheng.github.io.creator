---
title: "Java：线程池原理"
author: "Chenghao Zheng"
tags: ["Java"]
categories: ["Study notes"]
date: 2020-03-27T10:19:47+01:00
draft: false
---

本篇为 [Java：初识多线程、原理及实现](https://chenghao.monster/2020/java-multi-thread/) 的续篇，介绍 Java 中的线程池。

# 为什么需要线程池

### 进程与线程

#### 起源

**进程** 是在批处理操作系统的基础上，为进一步提高计算机效率，改善操作系统串行的运行方式的产物。进程的出现改变了内存中始终只有一个程序运行的事实，进程是在内存中独享一片内存空间的程序，各个进程之间互不干扰。

CPU 采用 **时间片轮转** 的方式运行进程，使用上下文切换的方式让操作系统的并发成为可能。虽然并发从宏观上看有多个任务在执行，但对于单核 CPU 来说，任意时刻都只有一个任务在占用 CPU 资源。

> 上下文指某一时刻 CPU 寄存器和程序计数器的内容，通过在内存中保存 / 读取来完成其切换。上下⽂切换通常是计算密集型的，意味着此操作会消耗⼤量的 CPU 时间，故线程也不是越多越好。如何减少系统中上下⽂切换次数，是提升多线程性能的⼀个重点课题。

如果说进程让操作系统的并发性成为了可能，那么 **线程** 就让进程的内部并发成为了可能。每个线程执行进程中的一个子任务，使得杀毒软件一遍检测用户电脑一遍清理垃圾成为可能。

#### 进程和线程的区别

1. 进程间的通信比较复杂，而线程间的通信比较简单。线程相比进程更为轻量级，多线程并发相比多进程开销更小。
2. 进程和线程本质的区别是 **是否单独占有内存地址空间及其他的系统资源（比如 I/O）**：进程间存在内存隔离，而线程共享所属进程占有的内存地址空间和隔离，数据共享简单，但是同步复杂。
3. 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。一个进程出现问题不会影响其他进程；而一个线程崩溃可能影响整个程序的稳定性。

### Java 线程与操作系统内核线程

#### 用户级线程与内核级线程

推荐阅读：[用户级线程和内核级线程，你分清楚了吗？](https://cloud.tencent.com/developer/article/1541432)

1. 用户级线程 ULT：由应用程序实现和管理（创建、同步、调度等），线程阻塞则整个进程阻塞。对操作系统来说，用户级线程具有不可见性、透明性，ULT 下 CPU 的调度还是以进程为单位。
2. 内核级线程 KLT：需通过 **系统调用** 创建，由系统内核管理，可实现多核 CPU 并行处理。线程阻塞不会影响同进程内其他线程的运行。

![](/images/system-memory.png)

#### 线程池的意义

* JVM 运行在用户态，通过调用系统库来创建内核线程，由 CPU 来完成线程的调度；但是从用户态到内核态的权限提升和状态切换需要相当的 **系统开销**，频繁的创建和销毁线程将不利于程序性能的提升。
* 为此，将线程池化管理，对线程进行统一分配、调优和监控，避免频繁的线程创建，减少状态切换带来的资源消耗，**重用线程** 就是使用线程池的意义。
* 线程池比较适合处理数量庞大，但是处理时间较短的任务。如果某个任务耗时过长，会导致池内任务堆积。

# 线程池原理

### ThreadPoolExecutor 的构造器参数

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) 
```

* corePoolSize：核⼼线程数
* maximumPoolSize：池内最大线程数

> 最大线程数 = 核心线程 + 非核心线程。非核心线程如果长时间闲置，就会被销毁。

* keepAliveTime / unit：非核心线程闲置超时时长 / 时间单位
* workQueue ==订单队列，保存哪些即将被执行的任务==，它是一个==阻塞队列==：在任意时刻，不管并发有多高，永远只有一个线程能够进行队列的入队或者出队操作！无界|有界；队列满，只能进行出队操作，所有入队的操作必须等待，也就是被阻塞；队列空，只能进行入队操作，所有出队的操作必须等待，也就是被阻塞；
* workQueue：阻塞的任务队列
* threadFactory：创建线程的工厂
* rejectedExecutionHandler：当任务队列满且无法再创建非核心线程时会执行拒绝处理策略
  * AbortPolicy 默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。  
  * CallerRunsPolicy：由调⽤线程处理该任务  
  * DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执⾏程序
  * DiscardPolicy：丢弃新来的任务  

### 线程池的状态

![](/images/线程池状态.png)



### 线程池主要的任务处理流程

### 四种常见的线程池

### 如何做到线程复用





