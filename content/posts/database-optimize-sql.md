---
title: "Database：高性能 MySQL - 优化查询"
author: "Chenghao Zheng"
tags: ["Database"]
categories: ["Reading notes"]
date: 2020-12-22T13:29:47+01:00
draft: false
---

一个 MySQL 的查询任务，可以看作是一系列子任务，每个子任务都会消耗一定的时间，包括：网络、CPU 计算、生成统计信息和执行计划、锁等待等。如果要优化查询，实际上要优化其子任务，消除其中的一些子任务，减少子任务的执行次数，让子任务运行得更快。因此，了解 **查询的生命周期**、清楚查询的时间消耗情况对于优化查询有很大的意义。

在 [Database：高性能 MySQL - 索引](https://nervousorange.github.io/2020/database-index/) 篇笔者已经讲述了索引对良好的性能有着重要的影响，但如果查询写的很糟糕，即使库表结果再合理、索引再合适，也无法实现高性能。本篇将结合 [《高性能 MySQL》](https://book.douban.com/subject/23008813/) 第六章 查询性能优化 的内容讲解 MySQL 如何真正地执行查询，查询高效和低效的原因何在，以及该如何合理的设计查询。

本篇依然基于和书本相同的 MySQL 5.5 版本，使用 [官方提供的测试数据库](https://github.com/datacharmer/test_db) 作为示例。


# 查询执行的基础

### MySQL 客户端/服务器通信协议

一般来说不需要去理解 MySQL 通信协议的内部实现细节，只需要大致理解通信协议是如何工作的。MySQL 客户端和服务器之间的通信协议是 "**半双工**" 的，这意味着在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生，无法也无须将一个消息切成小块独立来发送。

这种协议让 MySQL **通信简单快速**，但也给了 MySQL 一些限制，比如：

* 无法进行 **流量控制**，服务器必须接收客户端传来的完整查询消息才能响应，当查询语句过长超过 `max_allowed_packet` 时，服务器会拒绝接收并抛出错误。

* 客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这也是在必要的时候一定要在查询中加上 `limit` 限制的原因。

* MySQL 通常需要等所有数据都发送给客户端后才能释放这条查询所占用的资源，如果查询返回了一个很大的结果集，库函数会花很多时间和内存来存储所有的结果集，给服务器造成一定的压力。

### 查询执行流程

MySQL 执行一个查询的过程，大体上可分为服务器层和存储引擎层两部分：

#### Server 层

【转换成表格】

* 连接器：TCP 握手后服务器端验证登录用户身份

* 查询缓存：先检查查询缓存，如果命中则立刻返回存储在缓存中的结果

* 分析器：根据语法规则判断输入的 SQL 语句是否满足语法规范

* 优化器：选择并生成最优的执行计划

* 执行器：调用存储引擎的 API 执行查询

#### 存储引擎层

负责数据的存储和提取，MySQL 插件式的存储引擎架构支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，他从 MySQL 5.5 开始成为了默认的存储引擎。

![](/images/mysql_execution.jpg)

### 查询缓存

TODO

### 查询优化处理

在查询缓存没有命中后，Server 会将 SQL 转换成一个执行计划，MySQL 再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：

【转换成表格】

* 语法解析器：通过关键字和 MySQL 语法规则对 SQL 语句进行验证解析，生成一颗 "解析树"。

* 预处理器：进一步检查解析树是否合法，检查数据表、数据列是否存在，解析名字和别名是否有歧义 ---> 合法的语法树

* 查询优化器：找到并将语法树转化成最好的执行计划

MySQL 的查询优化器基于其成本模型选择最优的执行计划，并引入了估算某些操作（比如执行一次 where 条件比较）代价的因子，可以通过 `show status like Last_query_cost` 来得知 MySQL 当前计算的成本。优化器在评估成本的时候并不考虑任何层面的缓存，它假设读取任务数据都需要一次磁盘 I/0，优化器对于每种类型的查询所做的优化都不尽相同，具体的会在 **优化特定类型的查询** 中进行讲述。

# 慢查询基础：优化数据访问

### 是否请求了不需要的数据

查询性能低下的最基本的原因是访问的数据太多，对于低效的查询，可以分析下查询是否检索了大量超过需要的数据，确认 MySQL 是否分析了大量超过需要的数据行。

有些查询会请求超过实际需要的数据，然后将多余的数据丢弃，这会给 MySQL 服务器带来额外的负担，并增加网络开销，且消耗了应用服务器的 CPU 和内存资源。

一个常见的误解是认为 MySQL 会只返回需要的数据，实际 MySQL 却是先返回全部结果集再进行计算，一些开发者会使用 select 语句查询大量的结果，然后获取前面的 N 行后关闭结果集，应用程序会在接收全部的结果集数据后抛弃其中大部分数据，最简单有效的解决方法是在这样的查询后面加上 `limit`。

一些 DBA 是严格禁止 `select *` 写法的，取出所有列，会让优化器无法完成覆盖扫描这类优化，还会为服务器带来额外的 I/O、内存和 CPU 的消耗。但查询返回超过需要的数据也不总是坏事，一些开发者认为这种浪费数据库资源的方式可以简化开发，提高代码的复用性。如果应用程序对获取的所有的列进行缓存，这相比多个只获取部分列的查询可能更有好处。

对于不断重复执行、每次都返回相同数据的查询，比较好的方案是：在初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。

### MySQL 是否在扫描额外的记录

在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否使用了预期之外的访问类型、扫描了过多的数据，即扫描的行数对返回的行数的比率较大。也就是说，查询在存储引擎层执行时并不能高效地找到需要的数据，导致需要扫描大量的数据返回给服务器层，在服务器层过滤数据后才能取得需要的数据。

在 explain 语句中的 `type` 列反应了查询的访问类型，从全表扫描 all, 到索引扫描 index、范围扫描 range、索引查询 ref、常数引用 const 等，它们的速度从慢到快，扫描的行数也是从大到小。如果查询没有办法使用合适的访问类型，最好的解决办法通常是增加一个合适的索引，这也是笔者在 [Database：高性能 MySQL - 索引](https://nervousorange.github.io/2020/database-index/) 中所讲述的问题。

好的索引可以让查询使用合适的访问类型，在存储引擎层就使用索引过滤不匹配的记录，尽可能地只扫描需要的数据行，减少 I/O 次数。但有些查询需要扫描大量的数据却只返回少数的行，比如使用聚合函数 `count() + group by` 分组的查询，对这些查询通常也可以尝试以下技巧去尝试优化：

* 使用索引覆盖扫描，把所有需要的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。

* 改变库表结构，例如使用单独的汇总表。

### 一个复杂查询还是多个简单查询

在传统的数据库查询实现中，开发者总认为网络通信、查询解析和优化是一件代价很高的事情，强调数据库层要完成尽可能多的工作，然后写出一个较为复杂的查询。但这样的想法对于 MySQL 并不适用，MySQL 从设计上让连接和断开连接都很 **轻量级**，在返回一个小的查询结果方面很高效。现代的网络速度比以前要快很多，无论是带宽还是延迟，即使是一个千兆网卡也能轻松满足每秒超过 2000 次的查询，所以运行多个小查询现在已经不是大问题了。

有时候一个大语句可能会一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询，对此可以将一个大的语句切分成多个较小的查询，

# 优化特定类型的查询

### 优化 count() 查询

### 优化关联查询

### 优化子查询

### 优化 group by 和 distinct

### 优化 limit 分页

