---
title: "Database：高性能 MySQL - 优化查询"
author: "Chenghao Zheng"
tags: ["Database"]
categories: ["Reading notes"]
date: 2020-12-22T13:29:47+01:00
draft: false
---

一个 MySQL 的查询任务，可以看作是一系列子任务，每个子任务都会消耗一定的时间，包括：网络、CPU 计算、生成统计信息和执行计划、锁等待等。如果要优化查询，实际上要优化其子任务，消除其中的一些子任务，减少子任务的执行次数，让子任务运行得更快。因此，了解 **查询的生命周期**、清楚查询的时间消耗情况对于优化查询有很大的意义。

在 [Database：高性能 MySQL - 索引](https://nervousorange.github.io/2020/database-index/) 篇笔者已经讲述了索引对良好的性能有着重要的影响，但如果查询写的很糟糕，即使库表结果再合理、索引再合适，也无法实现高性能。本篇将结合 [《高性能 MySQL》](https://book.douban.com/subject/23008813/) 第六章 查询性能优化 的内容讲解 MySQL 如何真正地执行查询，查询高效和低效的原因何在，以及该如何合理的设计查询。

本篇依然基于和书本相同的 MySQL 5.5 版本，使用 [官方提供的测试数据库](https://github.com/datacharmer/test_db) 作为示例。


# 查询执行的基础

### MySQL 客户端/服务器通信协议

一般来说不需要去理解 MySQL 通信协议的内部实现细节，只需要大致理解通信协议是如何工作的。MySQL 客户端和服务器之间的通信协议是 "**半双工**" 的，这意味着在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生，无法也无须将一个消息切成小块独立来发送。

这种协议让 MySQL **通信简单快速**，但也给了 MySQL 一些限制，比如：

* 无法进行 **流量控制**，服务器必须接收客户端传来的完整查询消息才能响应，当查询语句过长超过 `max_allowed_packet` 时，服务器会拒绝接收并抛出错误。

* 客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这也是在必要的时候一定要在查询中加上 `limit` 限制的原因。

* MySQL 通常需要等所有数据都发送给客户端后才能 **释放这条查询所占用的资源**，如果查询返回了一个很大的结果集，库函数会花很多时间和内存来存储所有的结果集，给服务器造成一定的压力。

### 查询执行流程

MySQL 执行一个查询的过程，大体上可分为服务器层和存储引擎层两部分：

#### Server 层

| 阶段     | 职责                                                 |
| -------- | ---------------------------------------------------- |
| 连接器   | TCP 握手后服务器端验证登录用户身份                   |
| 查询缓存 | 先检查查询缓存，如果命中则立刻返回存储在缓存中的结果 |
| 分析器   | 根据语法规则判断输入的 SQL 语句是否满足语法规范      |
| 优化器   | 选择并生成最优的执行计划                             |
| 执行器   | 调用存储引擎的 API 执行查询                          |

#### 存储引擎层

负责数据的存储和提取，MySQL 插件式的存储引擎架构支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 开始成为了默认的存储引擎。

![](/images/mysql_execution.jpg)

### 查询缓存

TODO

### 查询优化处理

在查询缓存没有命中后，Server 会将 SQL 语句转换成一个执行计划，MySQL 再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：

| 阶段       | 职责                                                         |
| ---------- | ------------------------------------------------------------ |
| 语法解析器 | 通过关键字和 MySQL 语法规则对 SQL 语句进行验证解析，生成一颗 "解析树"。 |
| 预处理器   | 进一步检查解析树是否合法，检查数据表、数据列是否存在，解析名字和别名是否有歧义 |
| 查询优化器 | 将合法的语法树转化成最好的执行计划                           |

MySQL 的查询优化器基于其成本模型选择最优的执行计划，并引入了估算某些操作（比如执行一次 where 条件比较）代价的因子，可以通过 `show status like 'Last_query_cost'` 来得知 MySQL 当前计算的成本。优化器在评估成本的时候并不考虑任何层面的缓存，它假设读取任务数据都需要一次磁盘 I/0，优化器对于每种类型的查询所做的优化都不尽相同，具体的会在 **优化特定类型的查询** 中进行讲述。

# 慢查询基础：优化数据访问

### 是否请求了不需要的数据

查询性能低下的最基本的原因是访问的数据太多，对于低效的查询，可以分析下查询是否检索了大量 **超过需要的数据**，确认 MySQL 是否分析了大量超过需要的数据行。

* 有些查询会请求超过实际需要的数据，然后将多余的数据丢弃，这会给 MySQL 服务器带来额外的负担，并增加网络开销，且消耗了应用服务器的 CPU 和内存资源。一个常见的误解是认为 MySQL 会只返回需要的数据，实际 MySQL 却是先返回全部结果集再进行计算，一些开发者会使用 select 语句查询大量的结果，然后获取前面的 N 行后关闭结果集，应用程序会在接收全部的结果集数据后抛弃其中大部分数据，最简单有效的解决方法是在这样的查询后面加上 `limit`。

* 一些 DBA 是严格禁止 `select *` 写法的，取出所有列，会让优化器无法完成覆盖扫描这类优化，还会为服务器带来额外的 I/O、内存和 CPU 的消耗。但查询返回超过需要的数据也 **不总是坏事**，一些开发者认为这种浪费数据库资源的方式可以简化开发，提高代码的复用性。如果应用程序对获取的所有的列进行缓存，这相比多个只获取部分列的查询可能更有好处。

* 对于不断重复执行、每次都返回相同数据的查询，比较好的方案是：在初次查询的时候将这个数据 **缓存** 起来，需要的时候从缓存中取出，这样性能显然会更好。

### MySQL 是否在扫描额外的记录

在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否使用了预期之外的访问类型、扫描了过多的数据，即扫描的行数对返回的行数的比率较大。也就是说，查询在存储引擎层执行时并不能高效地找到需要的数据，导致需要扫描大量的数据返回给服务器层，**在服务器层过滤数据** 后才能取得需要的数据。

在 explain 语句中的 `type` 列反应了查询的访问类型，从全表扫描 all, 到索引扫描 index、范围扫描 range、索引查询 ref、常数引用 const 等，它们的速度从慢到快，扫描的行数也是从大到小。如果查询没有办法使用合适的访问类型，最好的解决办法通常是增加一个合适的索引，这也是笔者在 [Database：高性能 MySQL - 索引](https://nervousorange.github.io/2020/database-index/) 中所讲述的问题。

好的索引可以让查询使用合适的访问类型，**在存储引擎层就使用索引过滤不匹配的记录**，尽可能地只扫描需要的数据行，减少 I/O 次数。但有些查询需要扫描大量的数据却只返回少数的行，比如使用聚合函数 `count() + group by` 分组的查询，对这些查询通常也可以尝试以下技巧去尝试优化：

* 使用索引覆盖扫描，把所有需要的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。

* 改变库表结构，例如使用单独的汇总表。

### 一个复杂查询还是多个简单查询

在传统的数据库查询实现中，开发者总认为网络通信、查询解析和优化是一件 **代价很高** 的事情，强调数据库层要完成尽可能多的工作，然后写出一个较为复杂的查询。但这样的想法对于 MySQL 并不适用，MySQL 从设计上让连接和断开连接都很 **轻量级**，在返回一个小的查询结果方面很高效。现代的网络速度比以前要快很多，无论是带宽还是延迟，即使是一个千兆网卡也能轻松满足每秒超过 2000 次的查询，所以运行多个小查询现在已经不是大问题了。

~~~mysql
select * from tag 
join tag_post on tag_post.tag_id = tag.id 
join post on tag_post.post_id = post.id 
where tag.tag = 'mysql';

/** 可以分解成下面的查询来代替 */
select * from tag where tag = 'mysql';
select * from tag_post where tag_id = 1234;
select * from post where post.id in (123, 456, 567, 9098, 8904);
~~~~

* 有时候一个大的更新语句可能会一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询，对此可以将一个大的更新语句切分成多个较小的语句，降低对服务器的影响，减少删除时锁的持有时间。
* 很多高性能的应用都会对关联查询进行分解，将结果再应用中进行关联。分解关联查询有以下好处：
  1. 使用 IN() 代替关联查询，按照索引顺序查询可能比随机的关联更高效
  2. 语句被分解后，单个简单查询可以减少锁的竞争
  3. 可以减少冗余记录的查询，在数据库中做嵌套循环关联可能会重复地访问一部分数据，而在应用层做关联对同样的记录只需要查询一次
  4. 让缓存的效率更高，可以方便地缓存单表查询的结果对象
  5. 在应用层做关联，更容易对数据库进行拆分，做到高性能和高扩展

# 优化特定类型的查询

### 优化 count() 查询

count() 聚合函数很可能是 MySQL 中最容易被误解的前 10 个话题之一。`count (expression)` 统计表达式有值（不为 Null）的结果数，当 expression 不可能为空时，实际上就是在统计行数，比如 count(1)、count(*)，通配符 * 并不会像我们猜想的那样扩展成所有的列，实际上它会 **忽略所有的列**，直接统计行数。

MyISAM 中不带任何 where 条件的 count(*) 非常快。
* 因为无须实际地区计算表的行数，MySQL 可以利用存储引擎的特性直接获得这个值（MyISAM 维护了一个变量来放数据表的行数）。
* 但当统计带 where 子句的结果集行数，可以是统计某个列值的数量时，MyISAM 的 count() 和其他的存储引擎没有任何不同。
* 有时候可以利用 MyISAM count(*) 全表非常快的特性做一些优化：

~~~mysql
select count(*) from world.City where id > 5

/** 将条件反转，用总数去减，就可以将扫描的行数减少到 5 行以内，count(*) 子查询会被直接当做一个常数来处理 */
select(select count(*) from world.City) - count(*) from world.City where id <= 5
~~~

例：如果要查询返回各种不同颜色的商品数量

~~~mysql
select sum(IF(color = 'blue', 1, 0)) as blue, sum(IF(color = 'red', 1, 0)) as red from items;

/** 或者使用 count() 而不是 sum() 来实现同样的目的，设置满足条件为真，不满足条件为 Null 即可 */
select count(color = 'blue' OR Null) as blue, count(color = 'red' OR Null) as red from items;
~~~

一般来说 count（） 查询都需要扫描大量的行（意味着访问大量数据）才能获得精确的结果，因此是比较难优化的，可以考虑使用索引覆盖扫描，或者增加汇总表（外部缓存）。不过很快就会陷入到一个熟悉的困境，"快速，精确和实现简单"，三者永远满足其二，必须舍弃掉其中一个。


### 优化关联查询

### 优化子查询

### 优化 group by 和 distinct

### 优化 limit 分页

